require 'monitor'
require 'net/dns'
require 'net/dns/resolver'


module ProxyConf
  class NginxConfiguration
    
  attr_reader :dns_map 
  
  public  
    # Constructor
    # @param [Hash] config Data from configuration file
    def initialize(config)
      @config = config
      @applications = Hash.new { |h,k| h[k] = Hash.new { |h,k| h[k] = [] } }
      @dns_map = {}
      @dns_map.extend(MonitorMixin)
    end

    # Registers worker
    #
    # If DNS name is given, all IP addresses are registered. If worker is already registered does nothing.
    # @param [String] application_id Application id
    # @param [String] service_name Service name
    # @param [String] addr Service address
    
    def register(application_id, service_name, addr)      
      unless @applications[application_id][service_name].include? addr
        unless addr =~ /^\d+\.\d+\.\d+\d+(:\d+)?$/
          addr_parts = /^([^:]*)(:\d+)?/.match addr
          port = if addr_parts[2] then addr_parts[2] else ":80" end
          Net::DNS::Resolver.start(addr_parts[1], Net::DNS::A).each_address do |ip| 
            @dns_map.synchronize do 
              @dns_map[ip.to_s+port] = addr
            end
          end
        end
        @applications[application_id][service_name] << addr 

      end
    end

    # Unregisters worker
    #
    # If worker is not registered does nothing.
    # @param [String] application_id Application id
    # @param [String] service_name Service name
    # @param [String] addr Service address

    def unregister(application_id, service_name, addr)              
      if @applications.has_key? application_id and @applications[application_id].has_key? service_name then
        ret = @applications[application_id][service_name].delete addr 
        @dns_map.synchronize do 
           @dns_map.delete_if { |k,v| v == addr }
        end                                           
        # data structures cleanup
        @applications[application_id].delete service_name if @applications[application_id][service_name].size == 0
        @applications.delete application_id if @applications[application_id].size == 0
      end
      ret
    end

    # Returns hash of applications and their workers
    # @return [Hash]
    def list
      @applications
    end

  private
    # Generates header for nginx configuration
    def config_header
      "# DO NOT EDIT THIS FILE!\n# File generated by proxyconf at #{Time.now}\n\n"
    end

  
    # Generate nginx proxy config
    # @return Two element array: upstream configuration and proxy configuration.
    def configuration
      upstream = StringIO.new
      proxy    = StringIO.new

      upstream << config_header
      proxy << config_header


      @applications.each do |application, services|
        services.each do |service, workers|
          application_service_name = "app.#{application}.service.#{service}"
      
          # TODO sanitize vm.name
          # TODO Ticket #10
          upstream << "upstream #{application_service_name} { \n"
          upstream << workers.map { |worker| "\tserver #{worker};"}.join("\n")
          upstream << "\n}\n"
      
          proxy    << <<-CONFIG
  location /#{application}/#{service}/ {
    proxy_read_timeout #{@config["proxy_timeout"]};
    proxy_pass http://#{application_service_name}/;
  }   
  CONFIG
        end
      end
      [upstream.string, proxy.string]   
    end

  public
    # Save nginx proxy config to disk and reload server configuration
    def configure
      upstream_config, proxy_config = configuration
      begin 
        File.open(@config["upstream_config"],"w") { |file| file.write upstream_config }
        File.open(@config["proxy_config"],"w") { |file| file.write proxy_config }

        File.open(@config["pid_file"]) do |file|
         pid = file.read.to_i
         Process.kill :SIGHUP, pid
        end
      rescue Errno::EACCES
        $stderr << "Error: Cannot write to config files\n"
        raise
      rescue Errno::ESRCH
        $stderr << "Warning: Nginx is dead - continuing\n"
      end      
    end
  end
end